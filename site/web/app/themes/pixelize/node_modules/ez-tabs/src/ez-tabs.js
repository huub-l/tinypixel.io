const EzTabs = function (selector, options = {}) {

	// Default Options
	let opts = {
		tabSelector: options.tabSelector || '.tabs',
		paneSelector: options.paneSelector || '.panes',
		defaultActive: options.defaultActive || 1,
		verticalTabs: options.verticalTabs || false,
		breakpoints: options.breakpoints || undefined
	};

	// Useful DOM nodes
	const selectorElements = typeof selector === 'string' ? document.querySelector(selector) : selector; // Check if selector is DOM node or string
	let tabs;

	// State Management
	let activeIndex = opts.defaultActive; // Currently active tab
	let previousIndex; // Last active tab

	/**
	 * This function sets the
	 *
	 * @param index - new active tab
	 */
	function updateIndex(index) {

		//  if the tab is already selected, exit call
		if (index === activeIndex) return;

		// Swap indexes around
		previousIndex = activeIndex;
		activeIndex = index;

		// Add/remove required classes
		Array.from(selectorElements.querySelectorAll(`*[ez='${activeIndex}']`)).forEach(indexes => indexes.classList.add('ez-active')); // Add ez-active class to new tabs
		Array.from(selectorElements.querySelectorAll(`*[ez='${previousIndex}']`)).forEach(indexes => indexes.classList.remove('ez-active')); // Remove ez-active class from previous tabs
	}

	/**
	 * This function watches for viewport size changes, and updates options on breakpoints
	 *    e.g. width > 1000 - verticalTabs = false,
	 *         width < 1000 - verticalTabs = true,
	 * @param bp - breakpoints
	 */
	function setBreakpoints(bp) {
		// If breakpoints is not an object, break.
		if (typeof bp !== 'object') return;

		// Initialise breakpoint set
		let breakpoints = [];

		// Loop over all breakpoints
		Object.entries(bp).forEach(([key, value]) => {

			// Push key onto breakpoint stack stack
			if (typeof parseInt(key) === "number") breakpoints.push(parseInt(key));
		});

		// Watch for window size changes
		window.addEventListener('resize', () => {

			// upperBreakpoint holds the nearest breakpoint that is greater than viewport width
			let upperBreakpoint = 0;

			// Loop over all breakpoints and find the next breakpoint
			breakpoints.forEach(bp => {
				if (bp < window.innerWidth && bp > upperBreakpoint) upperBreakpoint = bp;
			});

			// If the window is greater than the breakpoint, then get the new options and update opts
			if (window.innerWidth > upperBreakpoint) {
				const newOpts = bp[upperBreakpoint];
				opts = {...opts, ...newOpts};
			}

			updateBreakpoints();
		});
	}

	function updateBreakpoints() {
		// If vertical add modifier class to wrapper, if not remove
		if (opts.verticalTabs) {
			selectorElements.classList.add('ez-vertical');
		} else {
			selectorElements.classList.remove('ez-vertical');
		}
	}

	/**
	 * This function sets the initial tabs
	 */
	function initialize() {

		// Check if exists;
		if (!document.querySelector(selector)) return;

		// Setup tabs selector
		tabs = Array.from(selectorElements.querySelectorAll(`${opts.tabSelector} > .tab`)); // Get all tabs from tabSelector for future usage/modification

		// If vertical add modifier class to wrapper
		if (opts.verticalTabs) selectorElements.classList.add('ez-vertical');

		// Add click event listener to update current tab
		tabs.forEach(tab => tab.addEventListener('click', () => updateIndex(tab.getAttribute('ez'))));

		// Set the first tab as active
		Array.from(selectorElements.querySelectorAll(`*[ez='${activeIndex}']`)).forEach(indexes => indexes.classList.add('ez-active'));
	}

	initialize();
	setBreakpoints(opts.breakpoints);
};
module.exports = EzTabs;